# 메소드

메소드는 일반적으로 아래와 같이 선언한다.

```
public String exampleMethod() {
    //해당 기능
} 
```

메소드에는 6가지 구성요소가 있다.

1. 접근제어자
2. 반환타입 - 반환하는 값의 데이터 유형 또는 없을경우 `void`
3. 메소드명
4. 매개변수
5. 예외
6. 메소드로직

## 메소드 이름짓기

아무렇게나 내키는대로 쓰지말고 규칙대로

맨 앞글자는 소문자며, 구분되는 단어가 생기면 대문자로 써준다.

`exampleMethod`

## 오버로딩

메소드는 클래스 내에서 고유한 이름을 갖는다. 하지만 `메소드 오버로딩` 이라는 기능을 통해

메소드이름은 같지만, 매개변수가 다른 메소드들을 여러개 선언할 수 있다.

```java
public class Example {
    
    public void helloWorld() {
        System.out.println("hello");
    }
    
    public void helloWorld(String name) {
        System.out.println("hello" + name);
    }
}
```

똑같은 메소드명에 똑같은 매개변수를 사용하는 메소드를 2개를 만든다면

컴파일러가 구분할 수가 없기 때문에 2개 이상 선언할 수 없다.

컴파일러는 메소드를 구분할 때 반환 형식을 고려하지 않으므로 반환 형식이 달라도

동일한 메소드 이름을 가진 메소드를 선언할 수 없다.

> 오버로딩한 메소드는 코드 가독성이 좋지 않으므로 남용해서는 안될것이다.

# 생성자

클래스에는 객체를 생성하기 위해 호출되는 생성자가 기본으로 포함되어 있다.

생성자는 반환 유형이 없으며 메소드 선언과 비슷하게 생겼다.

```java
public class Foo {
    
    private String string;
    
    public Foo(String string) {
        this.string = string;
    }
}

public class Main {
    public static void main(String[] args) {
        Foo foo = new Foo("test");
    }
}

```

`new Foo("test");` 는 메모리에 객체를 위한 공간을 만든 후에 필드를 초기화한다.

이 객체에는 생성자가 하나만 있지만, 인수가 없는 생성자를 포함하여

다른 생성자도 존재할 수 있다.

## 생성자 오버로딩

생성자도 메소드처럼 오버로딩이 가능하다.

마찬가지로 동일한 매개변수를 받는 것을 2개 이상 선언할 수 없다.

그렇게 하면 컴파일 오류를 맞이하게 될 것이다.

## Default 생성자

컴파일러는 생성자가 없는 모든 클래스에 대해 인수가 없는 기본 생성자를 자동으로 제공해준다.

기본 생성자는 슈퍼클래스의 인수가 없는 생성자를 호출한다.

클래스의 명시적 슈퍼클래스가 없는 경우 무조건 최상위 클래스인 `Object`가 슈퍼클래스가 된다.

그리고 이 생성자의 접근제한자를 전부 `private`로 바꾸게 되면

해당하는 클래스는 직접 생성해줄 수 없게 된다.

## 파라미터

메소드나 생성자에 대한 매개변수를 선언할 때 해당 매개변수의 이름을 제공한다.

이 변수명은 전달된 값을 참조하기 위해 메소드 내에서 사용된다.

## 메소드의 실행흐름

같은 클래스 내의 메소드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하다.

하지만, `static`메소드는 같은 클래스 내의 인스턴스 메소드를 호출할 수 없다.

## Return문

`return`문은 현재 실행중인 메소드를 종료하고 호출한 메소드로 되돌아간다.

모든 메소드에는 반드시 하나의 `return`이 있어야 한다.

void의 경우엔 return을 생략한 것이다.

분기문을 썼더라면 분기를 안타는 부분도 같이 `return`을 사용해주어야 한다.

```java
public class Foo {
    int add(int x, int y) {
        if (x < 0) {
            return -1;
        }
    }
}
```

예시처럼 한 경우에는 0보다 클 때는 return을 해주는 것이 없다.

그렇기에 항상 결과를 받을 수 있게끔 해주어야 한다.

## this 키워드

`this` 키워드는 참조변수로 인스턴스 자기 자신을 가리킨다.

참조변수를 통해 인스턴스의 멤버에 접근하듯이 `this`로 접근을 하는 것이다.

이 때에 `static`이 붙어있는 것들은 마찬가지로 사용할 수 없다. `static`이 붙은 것들은

인스턴스가 생성이 되지 않아도 호출이 가능하기 때문에 이 때 인스턴스가 존재하지 않는다면 에러가 발생하기 때문이다.

- `this`
  - 인스턴스 자신을 가리키는 참조변수
  - 인스턴스의 주소가 저장되어 있다.
  - 모든 인스턴스 메소드에 지역변수로 숨겨진 채 존재
- `this(), this(매개변수)`
  - 생성자
  - 같은 클래스의 다른 생성자를 호출할 때 사용

## 초기화 블럭

이부분을 처음 봤다.

아무래도 기초가 부족한 느낌이 있다.

초기화 블럭에는 두가지가 있는데,

클래스 초기화와 인스턴스 초기화 두개가 있다.

클래스 초기화 블럭은 해당 클래스가 처음 메모리에 로딩될 때 한번만 수행되며,

인스턴스 초기화 블럭은 생성자와 같이 인스턴스가 `new`로 생성될 때마다 수행된다.

> 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다❗️❗️❗️

인스턴스 변수의 초기화는 주로 `생성자` 를 사용하고,

공통으로 수행되는 중복 로직의 경우에는 인스턴스 초기화 블록을 사용한다.

> 객체지향 프로그래밍의 궁극적 목표는 재사용성을 높이고 중복을 줄이는것!!

