# 객체지향 프로그래밍 II

# 상속

상속이란, 기존에 있던 클래스를 재사용하여 새로운 클래스를 작성하는 것

코드를 공통적으로 관리할 수 있어 **코드의 추가 및 수정**이 용이하다.

이런 특징이

`코드의 재사용성을 높이고 코드의 중복을 제거` 하여 **생산성과 유지보수**에 크게 기여함.

```java
class Child extends Parent {
    // ...
}
```

위의 예시처럼 상속 받고자 하는 클래스를 `extends`를 붙여 사용하면 된다.

이랬을 때 `Parent` 클래스의 멤버 변수도 사용할 수가 있다.

`단, private는 사용할 수 없다.`

## 포함관계

상속 외에 클래스를 재사용하는 방법인 포함 관계

자동차에 바퀴는 _포함_ 된다.

```java
class Car {
    Wheel wheel = new Wheel();
}
```

이처럼 Car클래스 안에 멤버변수로 선언 후 인스턴스화를 진행하게 되면 포함관계가 된다.

- 상속 
  - `is a (~은 ~이다)`
- 포함 
  - `has a (~는 ~을 가지고 있다)`

이 두개를 생각해보면 된다.

## 단일 상속

자바는 다중 상속이 불가능하다.

이 기능이 당연해야 된다는 사실은

다중 상속을 진행했을 때, 두 개의 클래스가 똑같은 멤버변수를 갖거나, 동일한 메소드를 갖고 있을 경우

어느것을 상속받아야 하는지 모를 것이다.

그래서 자바는 단일상속만을 허용한다.

## Object

Object 클래스는 자바 세계에서 최상위에 있는 클래스이다.

보이지 않는 것일뿐, 우리가 클래스를 생성하면 `class Test extends Object` 가 

기본적으로 되어있는 것이다.

`toString()`, `equals()`, `hashCode()` 등등 Object클래스가 가지고 있는것들이

클래스에서 재정의를 할때 `@Override` 오버라이딩이 되어 써지는 것을 볼 수 있다.

# 오버라이딩

부모 클래스로부터 상속받은 메소드의 내용을 재정의 하는 것을 오버라이딩이라고 한다.

## 오버라이딩의 조건

- 이름이 같아야 함
- 매개변수가 같아야 한다
- 반환타입이 같아야 한다

---

접근 제어자는 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.

접근 제어자 (넓은 것 -> 좁은 것)

`public - protected - (default) - private`

---

조상 클래스의 메소드보다 많은 수의 예외를 던질 수 없다.

인스턴스 메소드를 `static` 메소드로 또는 반대로 변경하면 오버라이딩 조건이 아니다.

## super

`super`는 자손클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.

`super`도 마찬가지로 클래스 변수나 클래스 메소드에는 접근할 수 없다.

오로지 인스턴스에만 접근이 가능하다.

## super()

상속관계에서 부모 클래스의 인스턴스 변수를 그대로 가져와서 사용하는 것이 있었는데,

왜 사용이 가능하냐면 바로 `super()` 키워드 때문이다.

부모 클래스의 생성자를 호출하는 것인데

명시적으로 호출하지 않으면 구현하고자 하는 자식클래스의 생성자에 기본적으로 `super()`가 들어가게 된다.

그래서 부모의 인스턴스 변수나 메소드를 선언할 수 있게 되는 것이다.

# package 와 import

## package

패키지는 클래스의 묶음이다.

관련된 클래스끼리 묶어서 클래스들을 관리하게 해준다.

클래스가 `.class` 확장자가 붙은 하나의 파일이고

패키지는 하나의 폴더이다.

패키지 선언은 ide에서 클래스를 생성할 때 해당하는 패키지 디렉토리를 명시하게 되어있다.

`package 패키지명;`

## import문

다른 패키지의 클래스를 사용하려면 패키지 경로가 포함된 클래스 이름을 사용해야 하는데,

이 때 명시해주는 것이 `import` 이다.

## import문의 선언

자바 소스파일 구성 순서는 아래와 같다.

- package문
- import문
- 클래스 선언

import문에서 클래스가 명시되어 있는 부분이 있고 `*`라는 와일드카드를 사용하여 해당 패키지의

모든 클래스를 사용할 수 있다.

이게 있어서 가능한건

```java
import java.time.LocalDateTime;

class Test {

    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
    }
}
```

이렇게 import를 사용함으로써

`java.time.LocalDateTime now = java.time.LocalDateTime.now();` 를 해주는 수고를 덜어준다.

`System`, `java.lang.*` 패키지의 클래스들은 패키지명 없이 사용하는데

묵시적으로 import문이 선언되어있다.

static import는 `Assertions.assertThat()`의 단정문을 사용하는 테스트 코드에서

원래라면

`import org.assertj.core.api.Assertions;` 로 해서 위와같이 사용했겠지만,

아래처럼 static을 사용하여 메소드를 호출해놓으면

`import static org.assertj.core.api.Assertions.assertThat;`

`assertThat()`을 바로 사용해도 된다.

